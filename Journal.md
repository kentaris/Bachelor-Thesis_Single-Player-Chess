# Journal

| Date | Title | Details |
|:-:|:-:|:-:|
|23.02|[Valid Move Generator (VMG)](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/blob/main/Bachelorarbeit/Stages/1_First_attempt/valid_moves.py)|I'm reading about PDDL and getting a better idea on how to implement chess in PDDL. I apparently need all possible states as a list in the the domain.ppdl file so I stopped reading and started to implement a python program that lists me all possible valid moves of a piece if only that piece is present on the board. I created a working terminal interface for it and calculated the possible valid moves for every piece to be able to verify my programm output. It's now 23:20 and I implemented all pieces. It seems to work properly and passes all tests. I hope I can use the outputs and don't find out that it was all for nothing. But even then... it still was fun to do.|
|24.02|[FEN decoder/encoder](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/blob/main/Bachelorarbeit/Stages/1_First_attempt/FEN.py)|Today I tried to implement the PDDL Knight's tour problem but I got 0 solutions as an answer after ~10 seconds. I also tried to imlement the full chess problem with :types but not sure how to do it yet. I then realized some things that were missing which I may need later on and added some more functionality to the .py file I started doing yesterday and I also implemented a FEN notation decoder/encoder which takes one of either the FEN code or the board position as input and gives me the other. the FEN.py also has functions to get the fullmoves, halfmoves, castling rights, who's turn it is and if en passant availability. I think I should have implemented everything in C++ from the get go but not sure if I should switch now or not. I probably should. I should read more of haslum's chapter 2 so I am ready for my supervisor meeting is on monday. I didn't understand much of it the first time I went trough. I still have 37 pages to go trough carefully. I understood and tested most of the first part.|
|25.02|[PDDL File Generator](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/blob/main/Bachelorarbeit/Stages/1_First_attempt/populate_PDDL.py)|In my valid move generator I forgot to take into account that the black pawns move in the opposite direction and also that they can jump 2 squares on the first move. I separated the 6 cases and made them callable by calling pawns(color,type) where 'type' can be either 'all' valid moves, only capture moves (sideways) or only forward moves. I may need that in the future for my PDDL file so I have it ready now. I also wrote a program which saves me time and gives me overview in the pddl file by editing a template PDDL file and the program then automatically inserts the lists of valid moves and so on in the correct spot.|
|26.02|Fixing|Not much noticable has been coded today. I spent about an hour fixing some minor mistakes and cleaning up my code. I also spent some time reading some PDDL instructions on the internet to get a better idea of how to implement the full chess problem in PDDL. I'm still kind of lost at this point tough.|
|27.02|FEN decoder/encoder integration|Today I integrated the FEN decoder/encoder. I can now give my PDDL File Generator a FEN code and it will translate it will translate it in a series of fitting PDDL statements that are directly inserted into the PDDL file (instead of writing them by hand). This will make it way more easy later on to define a start position and a goal (end/ mate) position by just giving a FEN Code and it will automatically generate the PDDL file for me. Boards can now also optionally be printed out in color and with unicode chess symbols to make it more appealing to the eye. I also discovered a lot of bugs and potential problems which were either fixed now or marked as a possible source of errors with a ToDo etry.|
|28.02|Meeting|Today I had the meeting with Augusto. We now have a contract set up which is pending to be signed by everyone.|
|01.03|[Knight's-Tour](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/tree/main/Bachelorarbeit/Stages/2_Knights_Tour)|I completed the knights problem. It's mostly given in the book.|
|02.03|Two-Knight's-Tour|I worked on the 2-knights problem but I did get 'ff: goal can be simplified to FALSE. No plan will solve it' as an answer. If I comment out the restriction that the two knights can't be on the same square at the same time then I get 'Planner found 0 plan(s) in 11.005secs.'|
|03.03|[Two-Knight's-Walk](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/tree/main/Bachelorarbeit/Stages/3_Two_Knights_Walk)|I learned a lot about PDDL today and I will focus a bit more on reading from now on (instead of implementing). The Two-Knight's-Tour is now a Two-Knight's-Walk instead. Both knight's cannot be in the same spot at the same time and I got a plan with the help of Augusto ([planning.domain session](http://editor.planning.domains/#edit_session=kfziR44JuoW14XN)).|
|04.03|[README.md](README.md) cleanup|I didn't feel like continuing on the PDDL file so I did some unnecessary but fun styling work. I made my ReadMe look nice and tidy for both dark-mode and light mode GitHub users, created a logo for the project because I felt like doing it and I cleaned up some code in the FEN.py file so the board is nice and tidy in both dark-mode terminals and bright mode terminals.|
|07.03|Official start of my thesis|The contract has been signed and today in three months I'll be finished with my thesis. I already did some things before this date obviously because i was excided about it and could't wait to get started.|
|09.03|Meeting & Coding ([limited white pieces](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/tree/main/Bachelorarbeit/Stages/4_White_Pieces_limitated))|The meeting today with Augusto was productive, I know a lot more on how to continue and how to get it done. I'll be reading chapter 3 of the book for our next meeting. <br> The way the squares are labeled right now is problematic beause I cannot differentiate between vertical and horizontal movement. To solve this I introduced ranks and files which took way longer than I expected but it now seems to work. I also changed the objects hierarchy so it will be usable for the remainding figures of the board of both colors. I also changed the populate.py and population_generator.py accordingly to reflect this change. I also started encoding the pawn actions.|
|10.03|Pawn Moves|I implemented pawn moves. The planner is given a (FEN) starting position and can determine how to reach a given output position (using only knights and pawns so far). I tested it and it works. I also realized that I really don't need a two fold hirarchy for location (rows and cols) like I assumed yesterday so I reversed it.|
|11.03|King Moves|Today I implemented King moves. This was a rather short task.|
|12.03|Rook, Bishop & Queen Moves|Today I implemented Rook moves, Bishop moves and Queen moves and it seems to work in the cases I tested so far. From now I need to read chapter 3 of the book to be finished in time for the meeting with Augusto on tuesday so I'll already assign it to the jurnal.|
|13.03|Reading|Today I re-read parts of chapter 2 because I only skimm read them last time because some parts weren't very relevant and also didn't make much sense to me then but now they do.|
|14.03|reading chapter 3 & implement [black pieces](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/tree/main/Bachelorarbeit/Stages/5_white&black_limitated)|Today I implemented the black pieces. I still have 2 separate moves for black and white pawns which I don't like but I don' know how to combine them at this point. Each of the six figures is now extending both the figure category and also the color category. I hope this will make it easier to implement taking turns and also that I can merge the 2 pawn actions into one action so it is cleaner. At this point I haven't read chapter 3 but I will do so till the meeting with Augusto tomorrow at 11am.|
|15.03|Meeting|Meeting with Augusto|
|16.03|Fast Downward|Today I started using the state of the art planner called [Fast Downward](https://www.fast-downward.org/ObtainingAndRunningFastDownward) because editor.planning.domains is using a very old planner that does not support PDDL 2.2. and I started using Axioms. I can now use the command `foo@bar:~$ ./fast-downward.py chess-domain.pddl chess-problem.pddl --search "eager_greedy([ff])" ` to execute the planner and generate a plan file. I extended my [populate_PDDL.py](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/tree/main/Bachelorarbeit/Stages/6_all_rules_implemented/populate_PDDL.py) file so that it does the populating and executing of the plan in one step. This should save me some time and make the workflow more appealing. It also converts the text file plan to a .plan file which can be viewed in the vs code extension. I implemented pawn double moves with the derived predicates to test the water. pawn capturing will be implemented tomorrow.|
|17.03|Pawns|I tried to implement pawn captures with derived predicates and came across a problem: I cannot label the pawns correctly if they make an en-passant move: for example, if we have 3 pawns on the file n I cannot tell which of the 3 came from file n-1 and which from file n+1. I asked Augusto and he wrote: *"That is an interesting problem indeed. It will also occur with the other pieces actually -- e.g., the goal says that some rook should be in a specific position, but which one? One way we could solve it is to have predicates that indicate which piece (or none) is at a given position, instead of representing the specific object."* For now I just ignore this and to go around it I rewrote my FEN decoder to give me correctly labeled PDDL format positions when pawns move: the pawns (and other pieces) are now labeled by going trough columns of the board instead of rows.|
|18.03|Rook,pawn move & time|I created a module which tells me how long the planner needed to execute and which also tells me how much slower/faster it has executed since the last time it ran. I realized tough, that the program execution time varies even if every file involved stays the same so I need to take the average variation into account when making decisions. This way I have real time feedback on my changes and their performance (I measured it to be about 10ms on my laptop). I also implemented the rook and pawn moves with recursive derive predicates so the domain file is more compact and so I don't need multiple problem/domain files for different board sizes.|
|19.03|pawn capture|I tried to implement pawn captures but wasn't able to correctly identify if the color of the captured piece is not the color of the capturer piece. I messed around with it a lot but wasn't able to get closer to a result so I comented out the pawn capture for now. I also re-implemented Queen and Bishop movements the recursive derivatives approach.|
|20.03|fixing|I realized some strange behaviour with rook and bishop moves in certain szenarios which is now fixed. But one problem remains: bishops don't stay on the same diagonal. I tried to fix this by adding another recursive call in the "diag_reachable" derived predicate. This did fix the problem but now the bishop can only move one move at a time so I commented that line out again for now.|
|21.03|en passant, capturing & fixing|I found a rather easy way to fix my bishop problem by introducing a ned derived predicate "same_diag" which checks if the square (next_file,next_file) is on the same diagonal as the from- and to-squares. I implemented the en passant move for pawns with the help of Augusto. I tried to extraxt the color type of a pawn in a rather unnececarily complicated approach but Augusto pointed out that I can do it with simple static predicates which is what I did right now. Pawns can now capture opposite colored pieces. This means I can delete the color type. I realized that by doing so, the planner runns almost twice as fast as before! I also finished encoding the capturing of pieces. What is still missing is the condition that my own colored king can't be checked by moving my piece which is pinned.|
|22.03|Meeting & Optimizing|Today I had a productive meeting with Augusto. We discussed how to model checks and pins. For the pins: The king will walk into all directions up untill the end of the board and if it finds a piece of the opposite color that can capure it (bishop on diagonal for ex.) then the piece between the king and that piece cannot move. The king thereby moves trough exactly one own colored piece. I also came across a problem which I'm unable to fix at this point because I can't identify the source. Pawns can make a double move trough a piece that block it's way. But also rooks and other pieces have that problem if the piece stands exactly in front of them. While trying to locate the problem I rewrote large parts of the code but without success.As a side effect I did accomplish a speedup in runtime tough (by a factor of 2x on the same problem) which is nice. |
|23.03|castling|Castling action (kingside and queenside) is now implemented. There is one minor problem: I can't correctly identify if th rook I'm castling with is my rook or my opponents rook. This should only be a problem tough, if the starting position is a position where the rook of the opponent already is checking the king because as soon as a rook moves it can no longer castle so a opponent rook can't capture my own rook (for example) and then my king castles with it. Also As soon as check isimlemented this is no longer a problem because a king can't castle when he's in check.</br> </br>I wrote the following email to agugusto because I'm stuck at this point:</br>```I've been trying to get a hold of the in-check problem as we discussed but It is getting very complicated and slow very fast so I think this might not be the best idea. The king needs to check from the position he wants to move to if there is a piece that can capture him by moving into all directions of the board to look for such a piece. The problem here is: I need to further distinguish because the king can move diagonally towards a rook since he can only capture horizontally and vertically. The king can also move towards all other pieces (except the opponent king and queen) with some angle and I need to take this into account. I'm thinking if there is a better way to do it. Do you think it's possible to do some kind of virtual overlay? If I can get all pieces to label their paths as a sort of "red-zone" for the king into which he can't move this would be more efficient I think. Also, I don't need to worry about all the cases mentioned above. The king can then just check if he moves into a "red-zone" or not. And pieces can check if they have a red zone somewhere around them and if there is a king on the same line to check if they are pinned or not. I'm not sure if I can get this to work or not so I thought I'd run it by you first. I need to properly reset the "red-zones" every time a piece moves. Maybe I can have "red-zones" for all figures separately? This way I must only reset the red zones for the figure which moves. And maybe I can further distinguish between red zones for black and red zones for white? Do you think this will work?```</br></br>Also I realized that I can give the solver a "wrong" starting-&end-position combination and it will still solve it in some cases. For example the `start_FEN '5/5/Q4/R4/5'` and the `goal_FEN ='5/5/R4/5/5'`. The (formatted) output plan is: `queen_w1: A3->B4` & `rook_w1: A2->A3` which means that the queen just moves out of the way to make space for the rook. But It stays on a square that I did not define it to end up on. If I should allow this behaviour or if I should force the output to be " 'sas_plan' not fount " which would be more correct since the queen disappears in the input so the planner should not be able to solve this. Do you think I should enforce this by introducing a predicate like "removed" which must be true in the output? Or can I expect the input to be correct?|
|24.03|Reading|Augusto recommended that I read chapter 3,7,10, & 11 of the book 'Artificial Intelligence, A Modern Approach' by Stuart Russell. Today I read chapter 3 since I'm not able to do too much with my code except thinking about it because I'm waiting for Augustos thoughts on weather or not he thinks if my suggestion works or not.|
|27.03|Captured|I implemented captured pieces. Before, pieces that weren't mentioned in the FEN goal state could dissappear or stay on the board as they pleased. For example: the planner will give me a solution when given the start_FEN '5/5/Q4/R4/5' and goal FEN '5/5/R4/5/5' which is queen_w1: A3->B4 & rook_w1: A2->A3. This makes sense since the queen just moves out of the way to make space for the rook but the queen is still present in the solution but not in the given goal FEN. This is not the case anymore now and the planner returns "'sas_plan' not fount" now (in the case abouve).|
|28.03|adjusting|I fixed some minor issues that made the input sometimes ununiform so that I had to go and change the problem file by hand. now only the fen code can be given in all szenarios that I tested. this mostly concerns the removed pieces I implemenbted yesterday. I also went ahead and made the population_generator.py create the color types for me because I sometimes had to go and change it up by hand and I like it to be automatic so testing is easier and more percise.I also started to implement the check of the rook with the red zone approach.|
|29.03|meeting, unit tests|Today I had a meeting with Augusto, he was very helpfull as always and immediately saw some problems in my code which he pointed out. the rookis now able to check the king. Also I implemented unit tests. I realized that while doing changes some things don't work anymore and I always catch this too late. I now have a file unit_test.py where I store all unit tests and they are executed with the command `python3 populate_PDDL.py test` which will give me a summary at the end of which ones found a solution and which ones did not. The ones who did not find a solution are considered as failed. Maybe I will also implement unit tests which should fail sometime but for now this is enough I think. Also I could check if the output plan is correct but I'm satisfied with the tests at the moment. I also found a problem with my numbering system. My Fen-Code interpreter labels pawns from 1 to n by going column by column from top to bottom. This is a problem when a pawn behind a pawn is captured or if a pawn between two other pawns is captured. Let's say the captured pawn is the 2nd pawn `pawn_w2` and in front of it is the 3rd pawn `pawn_w3`. When the pawn_w2 is missing in the goal state (aka has been captured), then the pawns are again labeled column wise from top to bottom and since pawn_w2 is missing my algorithm labels the pawn_w3 as pawn_w2. Whenever this happens, the planner takes way more time than it's supposed to. For example: this is solved in ~2secs: `[start_FEN='5/1pppp/1R1N1/PPP2/5',goal_FEN ='5/Ppp2/RPpN1/4p/5']` while the following has been going for at least an hour when I aborted it: `[start_FEN='5/1pppp/1R1N1/PPP2/5', goal_FEN ='5/PpP2/R1pN1/4p/5']`. There is just one little change: the additional en-passant move: b3->c4 at the end (white pawn captures black pawn).|
|30.01|fixing & speed up|I discovered quite some problems which were causing wrong outcomes in certain szenarios. I fixed it and added unit tests to check them. right now the uni tests only check if a solution is found but I want to expand it at some point that they check if the solution is correct. The only reason i dod not do this at this point is because the output plan changes as I make changes to the pddl files so this will be added later. I also discovered a problem where unsolvable :init & :goal states are given but the planner keeps going for hours without outputting 'plan not found'. Mostly that is because of the problem with the numbering of pieces I mentioned yesterday but I cannot day that it is the only reason for it. Also I implemented checks for pawns. I also realized that I didn't implement en-passant, I just called it that. For enpassant I need to  check if the last move has been a double pawn move and I'm not yet sure how to do that.|
|31.03|pawn check, knight check & fixing|Pawn, rook and knight checks are implemented. I also started with the bishop but I ran into a weird problem that if 2 bishops were on the board weird behavior would happen. I had to go trough a lot of code until I could narrow down the origin of the mistake. The problem is the same as with the pawns described abouve somewhere. Since the bishops can't change the square color and because my Fen decoder automatically adds all the predicats needed in the problem file, the bishops don't match up in some configurations where there are 2 bishops present. I am now changing the structure so that the removed predicate correctly assigns the black and white squared bishop automatically.|
|01.04|fixing, bishop check, queen check|today I fixed the bishop assignment problem, now only the pawns will be able to cause mix up problems because I don't know which pawn has been captured so I can't correctly assign the end state pawns to the tart state pawns.|
|02.04|remove function|Today I was fighting with the removed function because I'm not able to get the logic right. I still haven't solved the problem.|
|03.04|fixing|I've uncovered some problems with some positions because my remove function is not always working correctly. I now fixed it and even simplified it a lot. My approach to it yesterday was unnececarily complicated. I now instead just compare the at predicates in the init and goal state and then add the removed predicates based on that instead of calculating them from the start and goal FEN like I tried in the last 2 days. Most unit tests are now working properly again. Pawns are still causing problems and I wrote augusto a mail about it. I'm not sure how to fix it. I could just implement a chess solver or use an existing one which checks if the given goal position is possible to reach and if so how the pawns can be labeled to acheave it. there are probably many options to get to some pawn positions (we can imagine 3 pawns in a row: we don't know if the n+1'th pawn came from the left and the n-1'th pawn from the right or the other way round for example, and those are not the only options. Best would be to implement it as a variable in PDDL but thats not possible in a goal position. I hope augusto has some input on this.|
|04.04|validation|Tonight I let my program run to see which problems present in my unit tests take how much time. I was suprised by how fast most of the problems are solved even with king checks in place. some problems take very long tough (10-25 minutes) and some don't finish after even a few hours. I now implemented a [validation tool](https://github.com/niklasf/python-chess). This is a great tool which can do many things but I only used it for one spot of my validator.py code. I directly take the original FEN, translate that FEN-code into a 8x8 board since the tool only accepts 8x8 boards, then I simulate a step by taking the first instruction lin in the .plan file given by the planner and move the piece accordingly. now I translate the board back into it's corresponding FEN code to be able to translate it into a chess board instance of the python-chess module with the line `board=chess.Board(FEN.board_to_FEN(start_board)+' w KQkq - 0 1')`. I also append the moves which can be performed by white in the next step: `chess.Move.from_uci(move) in board.legal_moves` which checks if the given move (ex: `a4h4` for a horizontal rook movement) is in the set of legal moves which can be taken from the given board position. I do this for every line in the .plan file. If one step fails, the validate method returns False else it returns true. I also print out the result into a .txt file so I don't loose it when it has run for several hours.|
|05.04|Meeting & taking turns|Today i had the meeting with Augusto. We discussed my progress and that I should get started with the report since it has been almost a month now since I started my thesis. We discussed how to implement pins and I'm planning topins tomorrow. Today I finished the taking turns but I commented it out for now so it doesn't mess up my unit tests since they weren't written with turn taking in mind and I'm not sure if they all work out well. I'll have to go trough them at some point but there are more important things to do right now such as the validation of the plan itself. I thought it worked yesterday but it really doesn't. The python-chess module I'm using is not returning all possibilities nor are the given possibilities all correct. I first thought that my code was the problem but it is not. I'm not sure if this is because the kings are missing in the positions I tested and the solver can't handle that. I'll try another solver for this. Implementing it by hand would be too much to ask for this thesis I think and if I only implement it half hearthedly without the restrictions such as pins and so on then it won't be of much use as a validation.|
|06.04|validator.py|Today i fixed the validator, it's now working properly.|
|07.04|One month|today I passed the first month of my thesis, 3 more months to go. I fixed the turn taking, I thought it was working but it wasn't: I assumed that an action effect where I set (not(white_s_turn)) it will act as a toggle (setting it to it's opposite value) but I found out that it only sets it to false where it will stay. This is now solved with an ADL conditional effect. I also implemented a (not(my_king_in_check ?figure)) derived predicate and inserted it at all relevant spots so it should work. I wasn't able to test it tough because the pawns aren't removed anymore. I thought this would not be a problem but apparently it is. I'm getting wrong positions. Remember when we added the '(white_pawn_at ?file ?rank - location)' predicate? this works great but since I can't declare that some pawn has been removed since I don't know where that last pawn's location will be, I came up with a different approach where I don't say that a pawn has been removed but how many pawns are present on the board. I tried to do this with a :function '(amount_of_pawns)' and then I decrease the amount every time a piece which is a pawn has been captured (in the :effect part of the action). however the planner is outputting: b'Undeclared predicate: decrease\n' even tough I added the ':action-costs' tag to the requirements (I also tried ':fluents' without success). I wasn't able to fix it on my own so I contacted Augusto.|
|08.04|Writing|Today I started writing the first part of my thesis. I'm not sure wheather or not I should continue coding while waiting for Augustos response because the last few times I did that, it was hard to locate the problem because I worked on some things simultaniously.|
|09.04|tough schedule|today I got a mail from augusto that he's worried about our schedule which in onther words means I'm too slow. I'm kind of paniking as I'm writing this. I implemented pinned pieces. it's not tested yet tough since there are some unit tests that fail which means I need to fix those first before I change more.|
|10.04|en-passant, testing&fixing| I implemented en-passant but did not test it yet. I fixed various problems with checks that occured. One of them took me half of the day to find and it turned out to be in a spot I would have never looked for. I only found it because I tried to optimize something small out of frustration. I also almost finished pawn promotion but there is a small detail I don't have an idea how to fix right now.|
|11.04|testing & fixing|I already found so many mistakes but somehow more and more mistakes come to the surface. The python code is pretty much done but there are problems in my almost 1k lines pddl domain file in certain special cases.|
|12.04|Meeting & pawn promotion|I thought pawn promotion would be easy to implement but it took quite a bit longer than I expected. I needed to rewrite some pddl populating functions to be able to handle more pieces than are present on the board and to correctly show them which means I also had to take into account the goal_FEN which triggered a cascade of changes. Also the pddl files needed additional pieces so I added a function which adds those to be able to promote.|
|12.04|fixing|a lot of fixing has been done today. This pddl part seems to have no end in sight.|
|13.04|populating|Today I made major steps forward. The pddl file is now completely populated by the logic of the gven FEN code. Only thing that is missing is a few extra pieces for pawn promotions. I'm not sure if this affects performance and since I still need tot test some things I'll create an extra function in which I can define how many extra pieces I want present. also I found the mistake that has been plaguing me for weeks now. as soon as the king was present there was a huge surge in time consumption for a task and it took forever so I never really was able to test my implementation except in subcases where I commented out parts of the code. However if all the code was uncommented it took forever and I just assumed that the complexity is just much higher. But after going through all 1300 lned of the domain.pddl file and tripple checking the logic I found that there was a simple negation that made some cases unsolvable which in turn made the planner run for very long. Those same cases now run within minutes.|
|14.04|Testing|Today was testing day. I discovered some minor issues like pawns that were able to move to the last rank which is not a valid move and the validator still tells me it's an invalid move now even tough it promotes to a queen but I'm gonna leave it at that since the plan is correct in that case. All unit tests that run within reasonable amount of time give me a correct plan which is validatable with the validate.py class and I do this in one batch. I also tested the unit tests which run for a long time by uncommenting some parts of the pddl code. Also since I enlarge the board by adding white space to it so the validator can take my board as an input (it's currently 5x5) there are problems with that since on a 5x5 board a pawn may still double move but on a 8x8 board that pawn cannot since it's in the middle of the board. The planner then correctly tells me its a invalid move altough in the original 5x5 board it would be a valid move. I will not address this issue.|
|15.04|Bitmaps|Today I started the second part of my thesis which is the implementation of a chess search algorithm in java. For now I transcribed the FEN decoder from my python file to the java file. I then realized that translating the Fen code to a 2d array makes no sense because I read [this](https://core.ac.uk/download/pdf/33500946.pdf) thesis about how the chessboard can be represented as 12 bitboards. I then started to re-implement the FEN decoder in java so that it directly translates the FEN-code into an 1d array of length 12 containing strings which consist of 1's and 0's with length 64. 1's represent where the piece is currently at. It then gets translated into a long (64bit) with `Long.parseLong` which gives me an array of 12 numbers which are my bitboards.|
|16.04|Bitmaps|More reading on bitmaps has been done today. There are some fantastic ressources and I'm kind of in love with the idea of bitboards because it is kind of like programming in pddl but with more control and error feedback. Lots of ideas can be taken over. I created lots of usefull methods which let me structure my code properly ad I took care that I can instantiate everything at the beginning only once and not every time over which is ultimately the idea of bitboards otherwise they are just like arrays. I also started creating methods which generate a bitboard which marks the files and ranks but there are some problems with the conversions of some of the bit strings to the 64 long bit.|
|17.04|Bitmaps|I solved the problem with the conversion from bit string to bit long, the problem was that I used `parseLong()` which is signed instead of `parseUnsignedLong()`. I've gotten used to the bitmaps way more now and was able to create bitboards for white pieces, blackpieces, bitboards that mark the queenside and kingside and empty squares. mpty squares is really easy since I can do a bitcode addition with `EMPTY=~(BLACKPIECES+WHITEPIECES)` which is awesome and shows the power and speed of bitmaps.|
|18.04|Moves (pawns & knights & kings)|Today I added possible pawn & knight moves (black and white) functions which give me a bitmap representing the squares that can be targeted. This is really fast.|
|19.04|Meeting|Today was another meeting. Augusto decided to take a look at the PDDL files himself and have a look at the internlals of the fast downward planner to find out where exactly the planner gets stuck and if we can do something about it or if it is just a hard problem for the planner. We also considered using a cloud computer but since we don't know yet if it would be worth it he'll first have a look at the files. I also started creating a method which gives me the rows and rank mask of a sliding piece. It's harder than I thought because of all the conversions I need to keep in my head while debugging but I think I'm almost there. right now I have some mirroring problems in the lower parts of the matrix and I'm unable to find the problem. I also implemented a matrix which I can manipulate and insert pieces into so I am faster when I want to test positions instead of using FEN codes only. I can just comment out one line to make the FEN code translator work again.|
|20.04|sliding piece mask|I finished the vertikal&horizontal mask for a sliding piece. The mistake was the mix up of row and rank at one spot, I don't know why I didn't find this earlier. I also imlemented the diagonal mask for sliding pieces like the bishop (&queen). This was a bit more complicated and took me quite some time to get right. I'm a bit worried that if I continue in this tempo I won't be finished by the end of my contract. I also started encoding the consideration of pieces which block the way since pieces can captur opposite pieces but not pieces of the same color. I want to implement this as an optimization of the existing code by checking if the current piece is a piece of the opposite color and if so|
|21.04|diagonal and horizontal premature abortion|Today I started writing down some of the logic I've been implementing over the past few days. I made notes in the code so I'm able to copy it for later use into the thesis document. The logic is about finding the spots a sliding figure can go to. I've been extending it by a piece which aborts the movements prematurely if we find that the square is occupied by either our own or the opposite colored piece. This speeds up the algorithm a bit but the major part is that it also allows me to not double compute those spots but I can simply do it in one step. The logic is kind of crazy but I tested it touroughly and it worked in all cases tested. I also read about magic bitboards and the formulas they use for sliding pieces and I finally understand it. There was a moment today where I thought about abandoning my approach and continuing with the one that is accepted by most top tier chess engines but I luckyly didnt because my solution is working now.|
|22.04|Fixing|Today I had the idea that I can also fit in pins and checks into my function which marks the way of sliding pieces. This worked great with one exception: the pieces that were on the boarder were not added for some reason. It took me all day to find out what exactly the problem was. I finally found it: I was checking if the previous figure was capturable in the eraly stopping part. Now when I reached the last square the for loop stops so there is no square to check the previous one at the board_ize+1'th square because it stops at board_size. This resulted in some major changes because the whole logic changed as well. As a side effect, the code got much cleaner and is much easier to understand now. I also noticed that it is a few miliseconds faster now on average.|
|23.04|Red Zone| The red zone to which the king cannot move is implemented. I also now know how many pieces are attacking the king and where exactly those pieces are without generating significant extra calculations since most of it is done only when a king is in check and while we are anyways in that spot (sliding pieces) so this should be efficient. I can now also differentiate between attacking and moving pawns since moving pawns can't check the king or capture a piece. This is all needed because [(here is a consice explanation)](https://peterellisjones.com/posts/generating-legal-chess-moves-efficiently/) when there is more than one piece attacking the king, the only legal move is moving the king while when there is only one pice attacking the king, the attacker piece can also be captured to put the king out of check OR move a piece between the king and the attacker piece to block the check. Furthermore I did some cleanup of the code, making it more compact. Today I am exaclty half way trough my thesis (45 more days to go).|
|24.04|check avoiding|I now added the piece valid movements which can capture the piece which is checking the king iff there is only one piece attacking the king (not possible if multiple pices are attacking the king). I also added blocked locations to which opposite piece can move to to avoid a check (again: only possible if there is only one attacker).|
|25.04|differentiating between different figures|Today I realized that my approach doesn't quite work the way I have it right now. To solve the problem of knowing which movemnt belongs to which figure, I had to create new movement maps for every single figure. Movement maps of figures of the same type are stored in an array of that type. There are still some bugs that camw with the migration to this new mapping but I'm confident that this is a good solution because it only generates very minimal amounts of overhead: the non-sliding piece movements need to be calculated one by one to differentiate between the pieces instead of all together. This also solves my complication of the situation with pins: so far I was only able to retrict the movements of all pieces of the pinned type because I wasn't able to assign the movements to a signular piece. Now this is no more a problem.|
|26.04|Meeting & Fixing|Today as another meeting with Augusto where we had a look at the PDDL files and some concerns he had. The concernes turned out to be misunderstandings fortunately which made me more confident in the validity of my pddl encoding. I Also found lots of bugs in my Bitboard generator. SOme of them I already fixed but others need more time.|
|27.04|restructuring|I ran into some performance issues when returning the full list of possible moves. this is not yet implemented correctly but the issue was lying elsewhere, namely in the wy I saved the bitmap movements. I united all of them into a single list and operated from there which made it difficult to access the individual moves. The issue is a similar one as I had with the individual maps for the pieces themselves.I now created another 2d array which contains different subarrays with different sizes. Those arrays represent the movements possible by each piece. These arrays were saved in an individual list before but I united them into one. This change resulted in some big restructuring of the code and also enabled me to simplify my code substantially. The issue with the performance is one I dont quite understand why it was happening: The computation time jumped from around 1ms for the same position to 5ms which is bad. Now it's back down again to around 1ms. I also tested the python-chess module: it apparently needs around 250Âµs to compute the same valid moves as my move generator thus I can say my engine is around 4 times slower. This is bad but I'm not sure if I have the time to implement the changes ("Using SIMD instructions to do bit-wise operations on multiple bit-boards at the same time. Using Kogge-Stone Generators when calculating slider moves for multiple pieces at the same time (e.g. calculating king danger squares or pin rays). Using the o^(o-2r) trick when calculating moves for individual sliding pieces, using the intel PSHUFB instruction to do byte-swaps on 128-bit registers to calculate diagonal attacks." - [source](https://peterellisjones.com/posts/generating-legal-chess-moves-efficiently/)). However if I add the movement outputs as strings, then the computation time jumps up to around 15ms. upon seeing this I rethought the problem and decided to return the bitmaps themselves instead of converting them to a string representation and dealing with that. At the end I will then convert the path which has been selected by the search algorithm and convert the selected steps to the corresponding string movements. I implemented the generation of all possible bitmaps now and the runtime is down from 15ms to 1.5 ms which is acceptable for now. I will come back to this if it turns out to be a bottleneck.|