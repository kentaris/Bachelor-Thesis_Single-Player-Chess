# Journal

| Date | Title | Details |
|:-:|:-:|:-:|
|23.02|[Valid Move Generator (VMG)](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/blob/main/Bachelorarbeit/Stages/1_First_attempt/valid_moves.py)|I'm reading about PDDL and getting a better idea on how to implement chess in PDDL. I apparently need all possible states as a list in the the domain.ppdl file so I stopped reading and started to implement a python program that lists me all possible valid moves of a piece if only that piece is present on the board. I created a working terminal interface for it and calculated the possible valid moves for every piece to be able to verify my programm output. It's now 23:20 and I implemented all pieces. It seems to work properly and passes all tests. I hope I can use the outputs and don't find out that it was all for nothing. But even then... it still was fun to do.|
|24.02|[FEN decoder/encoder](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/blob/main/Bachelorarbeit/Stages/1_First_attempt/FEN.py)|Today I tried to implement the PDDL Knight's tour problem but I got 0 solutions as an answer after ~10 seconds. I also tried to imlement the full chess problem with :types but not sure how to do it yet. I then realized some things that were missing which I may need later on and added some more functionality to the .py file I started doing yesterday and I also implemented a FEN notation decoder/encoder which takes one of either the FEN code or the board position as input and gives me the other. the FEN.py also has functions to get the fullmoves, halfmoves, castling rights, who's turn it is and if en passant availability. I think I should have implemented everything in C++ from the get go but not sure if I should switch now or not. I probably should. I should read more of haslum's chapter 2 so I am ready for my supervisor meeting is on monday. I didn't understand much of it the first time I went trough. I still have 37 pages to go trough carefully. I understood and tested most of the first part.|
|25.02|[PDDL File Generator](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/blob/main/Bachelorarbeit/Stages/1_First_attempt/populate_PDDL.py)|In my valid move generator I forgot to take into account that the black pawns move in the opposite direction and also that they can jump 2 squares on the first move. I separated the 6 cases and made them callable by calling pawns(color,type) where 'type' can be either 'all' valid moves, only capture moves (sideways) or only forward moves. I may need that in the future for my PDDL file so I have it ready now. I also wrote a program which saves me time and gives me overview in the pddl file by editing a template PDDL file and the program then automatically inserts the lists of valid moves and so on in the correct spot.|
|26.02|Fixing|Not much noticable has been coded today. I spent about an hour fixing some minor mistakes and cleaning up my code. I also spent some time reading some PDDL instructions on the internet to get a better idea of how to implement the full chess problem in PDDL. I'm still kind of lost at this point tough.|
|27.02|FEN decoder/encoder integration|Today I integrated the FEN decoder/encoder. I can now give my PDDL File Generator a FEN code and it will translate it will translate it in a series of fitting PDDL statements that are directly inserted into the PDDL file (instead of writing them by hand). This will make it way more easy later on to define a start position and a goal (end/ mate) position by just giving a FEN Code and it will automatically generate the PDDL file for me. Boards can now also optionally be printed out in color and with unicode chess symbols to make it more appealing to the eye. I also discovered a lot of bugs and potential problems which were either fixed now or marked as a possible source of errors with a ToDo etry.|
|28.02|Meeting|Today I had the meeting with Augusto. We now have a contract set up which is pending to be signed by everyone.|
|01.03|[Knight's-Tour](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/tree/main/Bachelorarbeit/Stages/2_Knights_Tour)|I completed the knights problem. It's mostly given in the book.|
|02.03|Two-Knight's-Tour|I worked on the 2-knights problem but I did get 'ff: goal can be simplified to FALSE. No plan will solve it' as an answer. If I comment out the restriction that the two knights can't be on the same square at the same time then I get 'Planner found 0 plan(s) in 11.005secs.'|
|03.03|[Two-Knight's-Walk](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/tree/main/Bachelorarbeit/Stages/3_Two_Knights_Walk)|I learned a lot about PDDL today and I will focus a bit more on reading from now on (instead of implementing). The Two-Knight's-Tour is now a Two-Knight's-Walk instead. Both knight's cannot be in the same spot at the same time and I got a plan with the help of Augusto ([planning.domain session](http://editor.planning.domains/#edit_session=kfziR44JuoW14XN)).|
|04.03|[README.md](README.md) cleanup|I didn't feel like continuing on the PDDL file so I did some unnecessary but fun styling work. I made my ReadMe look nice and tidy for both dark-mode and light mode GitHub users, created a logo for the project because I felt like doing it and I cleaned up some code in the FEN.py file so the board is nice and tidy in both dark-mode terminals and bright mode terminals.|
|09.03|Meeting & Coding ([limited white pieces](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/tree/main/Bachelorarbeit/Stages/4_White_Pieces_limitated))|The meeting today with Augusto was productive, I know a lot more on how to continue and how to get it done. I'll be reading chapter 3 of the book for our next meeting. <br> The way the squares are labeled right now is problematic beause I cannot differentiate between vertical and horizontal movement. To solve this I introduced ranks and files which took way longer than I expected but it now seems to work. I also changed the objects hierarchy so it will be usable for the remainding figures of the board of both colors. I also changed the populate.py and population_generator.py accordingly to reflect this change. I also started encoding the pawn actions.|
|10.03|Pawn Moves|I implemented pawn moves. The planner is given a (FEN) starting position and can determine how to reach a given output position (using only knights and pawns so far). I tested it and it works. I also realized that I really don't need a two fold hirarchy for location (rows and cols) like I assumed yesterday so I reversed it.|
|11.03|King Moves|Today I implemented King moves. This was a rather short task.|
|12.03|Rook, Bishop & Queen Moves|Today I implemented Rook moves, Bishop moves and Queen moves and it seems to work in the cases I tested so far. From now I need to read chapter 3 of the book to be finished in time for the meeting with Augusto on tuesday so I'll already assign it to the jurnal.|
|13.03|Reading|Today I re-read parts of chapter 2 because I only skimm read them last time because some parts weren't very relevant and also didn't make much sense to me then but now they do.|
|14.03|reading chapter 3 & implement [black pieces](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/tree/main/Bachelorarbeit/Stages/5_white&black_limitated)|Today I implemented the black pieces. I still have 2 separate moves for black and white pawns which I don't like but I don' know how to combine them at this point. Each of the six figures is now extending both the figure category and also the color category. I hope this will make it easier to implement taking turns and also that I can merge the 2 pawn actions into one action so it is cleaner. At this point I haven't read chapter 3 but I will do so till the meeting with Augusto tomorrow at 11am.|
|15.03|Meeting|Meeting with Augusto|
|16.03|Fast Downward|Today I started using the state of the art planner called [Fast Downward](https://www.fast-downward.org/ObtainingAndRunningFastDownward) because editor.planning.domains is using a very old planner that does not support PDDL 2.2. and I started using Axioms. I can now use the command `foo@bar:~$ ./fast-downward.py chess-domain.pddl chess-problem.pddl --search "eager_greedy([ff])" ` to execute the planner and generate a plan file. I extended my [populate_PDDL.py](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/tree/main/Bachelorarbeit/Stages/6_all_rules_implemented/populate_PDDL.py) file so that it does the populating and executing of the plan in one step. This should save me some time and make the workflow more appealing. It also converts the text file plan to a .plan file which can be viewed in the vs code extension. I implemented pawn double moves with the derived predicates to test the water. pawn capturing will be implemented tomorrow.|
|17.03|Pawns|I tried to implement pawn captures with derived predicates and came across a problem: I cannot label the pawns correctly if they make an en-passant move: for example, if we have 3 pawns on the file n I cannot tell which of the 3 came from file n-1 and which from file n+1. I asked Augusto and he wrote: *"That is an interesting problem indeed. It will also occur with the other pieces actually -- e.g., the goal says that some rook should be in a specific position, but which one? One way we could solve it is to have predicates that indicate which piece (or none) is at a given position, instead of representing the specific object."* For now I just ignore this and to go around it I rewrote my FEN decoder to give me correctly labeled PDDL format positions when pawns move: the pawns (and other pieces) are now labeled by going trough columns of the board instead of rows.|
|18.03|Rook,pawn move & time|I created a module which tells me how long the planner needed to execute and which also tells me how much slower/faster it has executed since the last time it ran. I realized tough, that the program execution time varies even if every file involved stays the same so I need to take the average variation into account when making decisions. This way I have real time feedback on my changes and their performance (I measured it to be about 10ms on my laptop). I also implemented the rook and pawn moves with recursive derive predicates so the domain file is more compact and so I don't need multiple problem/domain files for different board sizes.|
|19.03|pawn capture|I tried to implement pawn captures but wasn't able to correctly identify if the color of the captured piece is not the color of the capturer piece. I messed around with it a lot but wasn't able to get closer to a result so I comented out the pawn capture for now. I also re-implemented Queen and Bishop movements the recursive derivatives approach.|
|20.03|fixing|I realized some strange behaviour with rook and bishop moves in certain szenarios which is now fixed. But one problem remains: bishops don't stay on the same diagonal. I tried to fix this by adding another recursive call in the "diag_reachable" derived predicate. This did fix the problem but now the bishop can only move one move at a time so I commented that line out again for now.|
|21.03|en passant, capturing & fixing|I found a rather easy way to fix my bishop problem by introducing a ned derived predicate "same_diag" which checks if the square (next_file,next_file) is on the same diagonal as the from- and to-squares. I implemented the en passant move for pawns with the help of Augusto. I tried to extraxt the color type of a pawn in a rather unnececarily complicated approach but Augusto pointed out that I can do it with simple static predicates which is what I did right now. Pawns can now capture opposite colored pieces. This means I can delete the color type. I realized that by doing so, the planner runns almost twice as fast as before! I also finished encoding the capturing of pieces. What is still missing is the condition that my own colored king can't be checked by moving my piece which is pinned.|
|22.03|Meeting & Optimizing|Today I had a productive meeting with Augusto. We discussed how to model checks and pins. For the pins: The king will walk into all directions up untill the end of the board and if it finds a piece of the opposite color that can capure it (bishop on diagonal for ex.) then the piece between the king and that piece cannot move. The king thereby moves trough exactly one own colored piece. I also came across a problem which I'm unable to fix at this point because I can't identify the source. Pawns can make a double move trough a piece that block it's way. But also rooks and other pieces have that problem if the piece stands exactly in front of them. While trying to locate the problem I rewrote large parts of the code but without success.As a side effect I did accomplish a speedup in runtime tough (by a factor of 2x on the same problem) which is nice. |
|23.03|castling|Castling action (kingside and queenside) is now implemented. There is one minor problem: I can't correctly identify if th rook I'm castling with is my rook or my opponents rook. This should only be a problem tough, if the starting position is a position where the rook of the opponent already is checking the king because as soon as a rook moves it can no longer castle so a opponent rook can't capture my own rook (for example) and then my king castles with it. Also As soon as check isimlemented this is no longer a problem because a king can't castle when he's in check.</br> </br>I wrote the following email to agugusto because I'm stuck at this point:</br>```I've been trying to get a hold of the in-check problem as we discussed but It is getting very complicated and slow very fast so I think this might not be the best idea. The king needs to check from the position he wants to move to if there is a piece that can capture him by moving into all directions of the board to look for such a piece. The problem here is: I need to further distinguish because the king can move diagonally towards a rook since he can only capture horizontally and vertically. The king can also move towards all other pieces (except the opponent king and queen) with some angle and I need to take this into account. I'm thinking if there is a better way to do it. Do you think it's possible to do some kind of virtual overlay? If I can get all pieces to label their paths as a sort of "red-zone" for the king into which he can't move this would be more efficient I think. Also, I don't need to worry about all the cases mentioned above. The king can then just check if he moves into a "red-zone" or not. And pieces can check if they have a red zone somewhere around them and if there is a king on the same line to check if they are pinned or not. I'm not sure if I can get this to work or not so I thought I'd run it by you first. I need to properly reset the "red-zones" every time a piece moves. Maybe I can have "red-zones" for all figures separately? This way I must only reset the red zones for the figure which moves. And maybe I can further distinguish between red zones for black and red zones for white? Do you think this will work?```</br></br>Also I realized that I can give the solver a "wrong" starting-&end-position combination and it will still solve it in some cases. For example the `start_FEN '5/5/Q4/R4/5'` and the `goal_FEN ='5/5/R4/5/5'`. The (formatted) output plan is: `queen_w1: A3->B4` & `rook_w1: A2->A3` which means that the queen just moves out of the way to make space for the rook. But It stays on a square that I did not define it to end up on. If I should allow this behaviour or if I should force the output to be " 'sas_plan' not fount " which would be more correct since the queen disappears in the input so the planner should not be able to solve this. Do you think I should enforce this by introducing a predicate like "removed" which must be true in the output? Or can I expect the input to be correct?|
|24.03|Reading|Augusto recommended that I read chapter 3,7,10, & 11 of the book 'Artificial Intelligence, A Modern Approach' by Stuart Russell. Today I read chapter 3 since I'm not able to do too much with my code except thinking about it because I'm waiting for Augustos thoughts on weather or not he thinks if my suggestion works or not.|
|27.03|Captured|I implemented captured pieces. Before, pieces that weren't mentioned in the FEN goal state could dissappear or stay on the board as they pleased. For example: the planner will give me a solution when given the start_FEN '5/5/Q4/R4/5' and goal FEN '5/5/R4/5/5' which is queen_w1: A3->B4 & rook_w1: A2->A3. This makes sense since the queen just moves out of the way to make space for the rook but the queen is still present in the solution but not in the given goal FEN. This is not the case anymore now and the planner returns "'sas_plan' not fount" now (in the case abouve).|
|28.03|adjusting|I fixed some minor issues that made the input sometimes ununiform so that I had to go and change the problem file by hand. now only the fen code can be given in all szenarios that I tested. this mostly concerns the removed pieces I implemenbted yesterday. I also went ahead and made the population_generator.py create the color types for me because I sometimes had to go and change it up by hand and I like it to be automatic so testing is easier and more percise.I also started to implement the check of the rook with the red zone approach.|
|29.03|meeting, unit tests|Today I had a meeting with Augusto, he was very helpfull as always and immediately saw some problems in my code which he pointed out. the rookis now able to check the king. Also I implemented unit tests. I realized that while doing changes some things don't work anymore and I always catch this too late. I now have a file unit_test.py where I store all unit tests and they are executed with the command `python3 populate_PDDL.py test` which will give me a summary at the end of which ones found a solution and which ones did not. The ones who did not find a solution are considered as failed. Maybe I will also implement unit tests which should fail sometime but for now this is enough I think. Also I could check if the output plan is correct but I'm satisfied with the tests at the moment. I also found a problem with my numbering system. My Fen-Code interpreter labels pawns from 1 to n by going column by column from top to bottom. This is a problem when a pawn behind a pawn is captured or if a pawn between two other pawns is captured. Let's say the captured pawn is the 2nd pawn `pawn_w2` and in front of it is the 3rd pawn `pawn_w3`. When the pawn_w2 is missing in the goal state (aka has been captured), then the pawns are again labeled column wise from top to bottom and since pawn_w2 is missing my algorithm labels the pawn_w3 as pawn_w2. Whenever this happens, the planner takes way more time than it's supposed to. For example: this is solved in ~2secs: `[start_FEN='5/1pppp/1R1N1/PPP2/5',goal_FEN ='5/Ppp2/RPpN1/4p/5']` while the following has been going for at least an hour when I aborted it: `[start_FEN='5/1pppp/1R1N1/PPP2/5', goal_FEN ='5/PpP2/R1pN1/4p/5']`. There is just one little change: the additional en-passant move: b3->c4 at the end (white pawn captures black pawn).|
|30.01|fixing & speed up|I discovered quite some problems which were causing wrong outcomes in certain szenarios. I fixed it and added unit tests to check them. right now the uni tests only check if a solution is found but I want to expand it at some point that they check if the solution is correct. The only reason i dod not do this at this point is because the output plan changes as I make changes to the pddl files so this will be added later. I also discovered a problem where unsolvable :init & :goal states are given but the planner keeps going for hours without outputting 'plan not found'. Mostly that is because of the problem with the numbering of pieces I mentioned yesterday but I cannot day that it is the only reason for it. Also I implemented checks for pawns. I also realized that I didn't implement en-passant, I just called it that. For enpassant I need to  check if the last move has been a double pawn move and I'm not yet sure how to do that.|