# Journal

| Date | Title | Details |
|:-:|:-:|:-:|
|23.02|[Valid Move Generator (VMG)](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/blob/main/Bachelorarbeit/Stages/1_First_attempt/valid_moves.py)|I'm reading about PDDL and getting a better idea on how to implement chess in PDDL. I apparently need all possible states as a list in the the domain.ppdl file so I stopped reading and started to implement a python program that lists me all possible valid moves of a piece if only that piece is present on the board. I created a working terminal interface for it and calculated the possible valid moves for every piece to be able to verify my programm output. It's now 23:20 and I implemented all pieces. It seems to work properly and passes all tests. I hope I can use the outputs and don't find out that it was all for nothing. But even then... it still was fun to do.|
|24.02|[FEN decoder/encoder](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/blob/main/Bachelorarbeit/Stages/1_First_attempt/FEN.py)|Today I tried to implement the PDDL Knight's tour problem but I got 0 solutions as an answer after ~10 seconds. I also tried to imlement the full chess problem with :types but not sure how to do it yet. I then realized some things that were missing which I may need later on and added some more functionality to the .py file I started doing yesterday and I also implemented a FEN notation decoder/encoder which takes one of either the FEN code or the board position as input and gives me the other. the FEN.py also has functions to get the fullmoves, halfmoves, castling rights, who's turn it is and if en passant availability. I think I should have implemented everything in C++ from the get go but not sure if I should switch now or not. I probably should. I should read more of haslum's chapter 2 so I am ready for my supervisor meeting is on monday. I didn't understand much of it the first time I went trough. I still have 37 pages to go trough carefully. I understood and tested most of the first part.|
|25.02|[PDDL File Generator](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/blob/main/Bachelorarbeit/Stages/1_First_attempt/populate_PDDL.py)|In my valid move generator I forgot to take into account that the black pawns move in the opposite direction and also that they can jump 2 squares on the first move. I separated the 6 cases and made them callable by calling pawns(color,type) where 'type' can be either 'all' valid moves, only capture moves (sideways) or only forward moves. I may need that in the future for my PDDL file so I have it ready now. I also wrote a program which saves me time and gives me overview in the pddl file by editing a template PDDL file and the program then automatically inserts the lists of valid moves and so on in the correct spot.|
|26.02|Fixing|Not much noticable has been coded today. I spent about an hour fixing some minor mistakes and cleaning up my code. I also spent some time reading some PDDL instructions on the internet to get a better idea of how to implement the full chess problem in PDDL. I'm still kind of lost at this point tough.|
|27.02|FEN decoder/encoder integration|Today I integrated the FEN decoder/encoder. I can now give my PDDL File Generator a FEN code and it will translate it will translate it in a series of fitting PDDL statements that are directly inserted into the PDDL file (instead of writing them by hand). This will make it way more easy later on to define a start position and a goal (end/ mate) position by just giving a FEN Code and it will automatically generate the PDDL file for me. Boards can now also optionally be printed out in color and with unicode chess symbols to make it more appealing to the eye. I also discovered a lot of bugs and potential problems which were either fixed now or marked as a possible source of errors with a ToDo etry.|
|28.02|Meeting|Today I had the meeting with Augusto. We now have a contract set up which is pending to be signed by everyone.|
|01.03|[Knight's-Tour](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/tree/main/Bachelorarbeit/Stages/2_Knights_Tour)|I completed the knights problem. It's mostly given in the book.|
|02.03|Two-Knight's-Tour|I worked on the 2-knights problem but I did get 'ff: goal can be simplified to FALSE. No plan will solve it' as an answer. If I comment out the restriction that the two knights can't be on the same square at the same time then I get 'Planner found 0 plan(s) in 11.005secs.'|
|03.03|[Two-Knight's-Walk](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/tree/main/Bachelorarbeit/Stages/3_Two_Knights_Walk)|I learned a lot about PDDL today and I will focus a bit more on reading from now on (instead of implementing). The Two-Knight's-Tour is now a Two-Knight's-Walk instead. Both knight's cannot be in the same spot at the same time and I got a plan with the help of Augusto ([planning.domain session](http://editor.planning.domains/#edit_session=kfziR44JuoW14XN)).|
|04.03|[README.md](README.md) cleanup|I didn't feel like continuing on the PDDL file so I did some unnecessary but fun styling work. I made my ReadMe look nice and tidy for both dark-mode and light mode GitHub users, created a logo for the project because I felt like doing it and I cleaned up some code in the FEN.py file so the board is nice and tidy in both dark-mode terminals and bright mode terminals.|
|09.03|Meeting & Coding ([limited white pieces](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/tree/main/Bachelorarbeit/Stages/4_White_Pieces_limitated))|The meeting today with Augusto was productive, I know a lot more on how to continue and how to get it done. I'll be reading chapter 3 of the book for our next meeting. <br> The way the squares are labeled right now is problematic beause I cannot differentiate between vertical and horizontal movement. To solve this I introduced ranks and files which took way longer than I expected but it now seems to work. I also changed the objects hierarchy so it will be usable for the remainding figures of the board of both colors. I also changed the populate.py and population_generator.py accordingly to reflect this change. I also started encoding the pawn actions.|
|10.03|Pawn Moves|I implemented pawn moves. The planner is given a (FEN) starting position and can determine how to reach a given output position (using only knights and pawns so far). I tested it and it works. I also realized that I really don't need a two fold hirarchy for location (rows and cols) like I assumed yesterday so I reversed it.|
|11.03|King Moves|Today I implemented King moves. This was a rather short task.|
|12.03|Rook, Bishop & Queen Moves|Today I implemented Rook moves, Bishop moves and Queen moves and it seems to work in the cases I tested so far. From now I need to read chapter 3 of the book to be finished in time for the meeting with Augusto on tuesday so I'll already assign it to the jurnal.|
|13.03|Reading|Today I re-read parts of chapter 2 because I only skimm read them last time because some parts weren't very relevant and also didn't make much sense to me then but now they do.|
|14.03|reading chapter 3 & implement [black pieces](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/tree/main/Bachelorarbeit/Stages/5_white&black_limitated)|Today I implemented the black pieces. I still have 2 separate moves for black and white pawns which I don't like but I don' know how to combine them at this point. Each of the six figures is now extending both the figure category and also the color category. I hope this will make it easier to implement taking turns and also that I can merge the 2 pawn actions into one action so it is cleaner. At this point I haven't read chapter 3 but I will do so till the meeting with Augusto tomorrow at 11am.|
|15.03|Meeting|Meeting with Augusto|
|16.03|Fast Downward|Today I started using the state of the art planner called [Fast Downward](https://www.fast-downward.org/ObtainingAndRunningFastDownward) because editor.planning.domains is using a very old planner that does not support PDDL 2.2. and I started using Axioms. I can now use the command `foo@bar:~$ ./fast-downward.py chess-domain.pddl chess-problem.pddl --search "eager_greedy([ff])" ` to execute the planner and generate a plan file. I extended my [populate_PDDL.py](https://github.com/kentaris/Bachelor-Thesis_Single-Player-Chess/tree/main/Bachelorarbeit/Stages/6_all_rules_implemented/populate_PDDL.py) file so that it does the populating and executing of the plan in one step. This should save me some time and make the workflow more appealing. It also converts the text file plan to a .plan file which can be viewed in the vs code extension. I implemented pawn double moves with the derived predicates to test the water. pawn capturing will be implemented tomorrow.|
|17.03|Pawns|I tried to implement pawn captures with derived predicates and came across a problem: I cannot label the pawns correctly if they make an en-passant move: for example, if we have 3 pawns on the file n I cannot tell which of the 3 came from file n-1 and which from file n+1. I asked Augusto and he wrote: *"That is an interesting problem indeed. It will also occur with the other pieces actually -- e.g., the goal says that some rook should be in a specific position, but which one? One way we could solve it is to have predicates that indicate which piece (or none) is at a given position, instead of representing the specific object."* For now I just ignore this and to go around it I rewrote my FEN decoder to give me correctly labeled PDDL format positions when pawns move: the pawns (and other pieces) are now labeled by going trough columns of the board instead of rows.|
|18.03|Rook,pawn move & time|I created a module which tells me how long the planner needed to execute and which also tells me how much slower/faster it has executed since the last time it ran. I realized tough, that the program execution time varies even if every file involved stays the same so I need to take the average variation into account when making decisions. This way I have real time feedback on my changes and their performance (I measured it to be about 10ms on my laptop). I also implemented the rook and pawn moves with recursive derive predicates so the domain file is more compact and so I don't need multiple problem/domain files for different board sizes.|
|19.03|pawn capture|I tried to implement pawn captures but wasn't able to correctly identify if the color of the captured piece is not the color of the capturer piece. I messed around with it a lot but wasn't able to get closer to a result so I comented out the pawn capture for now. I also re-implemented Queen and Bishop movements the recursive derivatives approach.|
|20.03|fixing|I realized some strange behaviour with rook and bishop moves in certain szenarios which is now fixed. But one problem remains: bishops don't stay on the same diagonal. I tried to fix this by adding another recursive call in the "diag_reachable" derived predicate. This did fix the problem but now the bishop can only move one move at a time so I commented that line out again for now.|
|21.03|en passant, capturing & fixing|I found a rather easy way to fix my bishop problem by introducing a ned derived predicate "same_diag" which checks if the square (next_file,next_file) is on the same diagonal as the from- and to-squares. I implemented the en passant move for pawns with the help of Augusto. I tried to extraxt the color type of a pawn in a rather unnececarily complicated approach but Augusto pointed out that I can do it with simple static predicates which is what I did right now. Pawns can now capture opposite colored pieces. This means I can delete the color type. I realized that by doing so, the planner runns almost twice as fast as before! I also started encoding the capturing of pieces. It is not yet working tough.|